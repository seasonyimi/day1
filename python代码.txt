1.简单看输入的数
temp=input("请输入数字：")
guess=int(temp)
while guess != 100:
    if guess>100:
        print("大了大了")
    else:
         print("小了小了")
    temp=input("请输入数字：")
    guess=int(temp)
else:
     print("猜对")
print("游戏结束")
2、1-10里猜，只能猜三次 
import random
times=3
secret=random.randint(1,10)
#temp=input("请输入数字：")
#guess=int(temp)
guess=0
print("请输入猜想数字:",end="")
while (guess != secret) and (times>0):
    temp=input()
    guess=int(temp)
    times=times-1
    if guess==secret:
        print("猜对了")
    else:
        if guess>secret:
            print("大了大了")
        else:
            print("小了小了")
        if times>0:
            print("再试一次:",end="")
        else:
            print("机会用完")
print("游戏结束")
3、输入1-9的序列，隔两个输出（自写）
#d=[1,2,3,4,5,6,7,8,9]
print("请输入数列：")
d=input()
d=d.split(',')   #split分割输入的数据
x=len(d)
a=int(d[0])
print("输出结果：")
for b in range(a,x,2):
    print(b,end='|')



# dict字典
d = {'Michael':95,'Bob':85,'Tracy':70,'Michael':10}
print(d['Michael'])
d['Bob'] = 60
print(d['Bob'])
# 判断key值是否存在
print('Tracy' in d)
# dict 中 {'key':values} key是不能变的
# set和dict类似，但set中key不能重复,没有value
# 显示按顺序不是表示set排序。只是告诉你有这几个元素
s = set([1,3,2,1])
print(s)
s.add(4)
print(s)
s.remove(4)
print(s)
# 可看作数字意义上的无序和无重复元素集合，可进行交集和并集
s1 = set([1,2,3])
s2 = set([2,3,4])
print(s1 & s2)
print(s1 | s2)

# 参数组合
def f1(a,b,c=0,*args,**kw):
    print('a=',a,'b=',b,'c=',c,'arg=',args, 'kw=',kw)
def f2(a,b,c=0,*,d,**kw):
    print('a=',a,'b=',b,'c=',c,'d=',d,'kw=',kw)
print(f1(1,2))
print(f1(1,2,c=3))
print(f1(1,2,3,'a','b'))
print(f1(1,2,3,'a','b',x=99))
print(f2(1,2,d=99,ext=None))


# 递归函数
# 这种情况会发生栈溢出
def fact(n):
    if n==1:
        return 1
    return n * fact(n-1)
print(fact(1))
print(fact(5))
# 优化方法
# 虽然改成了尾递归，但还是会溢出。这方面没有优化
def fact(n):
    return fact_iter(n,1)
def fact_iter(num,product):
    if num == 1:
        return product
    return fact_iter(num - 1, num * product)

# 汉诺塔
# 请编写move(n, a, b, c)函数，它接收参数n，表示3个柱子A、B、C中第1个柱子A的盘子数量，然后打印出把所有盘子从A借助B移动到C的方法
def move(n, a, b, c):
    if n == 1:
        print(a, '-->', c)
    elif n > 1:
        move(n-1,a,c,b)
        move(1,a,b,c)
        move(n-1,b,a,c)
move(4,'a','b','c')
print(fact_iter(6,3))


# 切片
L = ['Michael', 'Sarah', 'Tracy', 'Bob', 'Jack']
# 从索引1开始取，直到索引3为止，但不包括索引3
print(L[1:3])
# 倒数--从索引3开始取，直到索引1为止，但不包括索引3
print(L[-3:-1])
# 显示全部
print(L[:])
# 元组也可以切片
a=(4,5,3,6,2,9)
print(a[1:3])
# 字符串也可以切片
print('ABCDEFG'[1:3])



# 利用切片操作，实现一个trim()函数，去除字符串首尾的空格，注意不要调用str的strip()方法
def trim(s):
    if s[:1] != ' ' and s[-1:] != ' ':
        return s
    elif s[:1] == ' ':
        return trim(s[1:])
    else:
        return trim(s[:-1])
# 测试:
if trim('hello  ') != 'hello':
    print('测试失败!')
elif trim('  hello') != 'hello':
    print('测试失败!')
elif trim('  hello  ') != 'hello':
    print('测试失败!')
elif trim('  hello  world  ') != 'hello  world':
    print('测试失败!')
elif trim('') != '':
    print('测试失败!')
elif trim('    ') != '':
    print('测试失败!')
else:
    print('测试成功!')



#dict迭代
d = {'a':1,'b':2,'c':3}
for key in d :
    print(key)
for key in d.values():
    print(key)
for key in d.items():
    print(key)
# 字符串迭代
for ch in 'ABC':
    print(ch)
# 如何判断是否可以迭代
from collections import Iterable
print(isinstance('ABC',Iterable))
print(isinstance([1,2,3],Iterable))




#使用迭代查找一个list中最小和最大值，并返回一个tuple
def findMinAndMax(L):
    if len(L) == 0:
        return (None,None)
    else:
        (max,min)=(L[0],L[0])
        for n in L:
            if max < n:
                max=n
            if min > n:
                min=n
        return (min,max)
# 测试
if findMinAndMax([]) != (None, None):
    print('测试失败!')
elif findMinAndMax([7]) != (7, 7):
    print('测试失败!')
elif findMinAndMax([7, 1]) != (1, 7):
    print('测试失败!')
elif findMinAndMax([7, 1, 3, 9, 5]) != (1, 9):
    print('测试失败!')
else:
    print('测试成功!')
print(isinstance(123,Iterable))


x = 'abc'
y = 123
# 判断类型
print(isinstance(x, str))
print(isinstance(y,int))




L1 = ['Hello', 'World', 18, 'Apple', None]
L2 = [s.lower() for s in L1 if isinstance(s,str)]
# 测试:
print(L2)
if L2 == ['hello', 'world', 'apple']:
    print('测试通过!')
else:
    print('测试失败!')



g = (x*x for x in range(11))
for i in g :
    print(i)

'''
比如，著名的斐波拉契数列（Fibonacci），除第一个和第二个数外，任意一个数都可由前两个数相加得到：
1, 1, 2, 3, 5, 8, 13, 21, 34, ...
'''
def fid(max):
    n,a,b = 0, 0, 1
    while n < max:
        print(b)
        '''
        下列相当于：
        t = (b, a + b) # t是一个tuple
        a = t[0]
        b = t[1]
       '''
        a,b = b, a+b
        n = n + 1
    return 'done'
fid(6)
#斐波拉契数列（Fibonacci）生成器
def fid(max):
    n,a,b = 0, 0, 1
    while n < max:
        yield b
        a,b = b, a+b
        n = n + 1
    return 'done'
for i in fid(5):
    print(i)



# 杨辉三角
def triangles():
    L=[1]
    width=6*len( L[:len(L)])
    while True:
        yield L[:len(L)]
        # 为数组最后加一位
        L.append(0)
        L = [L[i-1] + L[i] for i in range(len(L))]
n=0
results=[]
for t in triangles():
    print(t)
    results.append(t)
    n=n+1
    if n == 5 :
        break